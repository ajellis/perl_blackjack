.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::SQLite 3"
.TH DBD::SQLite 3 "2005-12-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::SQLite \- Self Contained RDBMS in a DBI Driver
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use DBI;
\&  my $dbh = DBI\->connect("dbi:SQLite:dbname=dbfile","","");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQLite is a public domain \s-1RDBMS\s0 database engine that you can find
at http://www.hwaci.com/sw/sqlite/.
.PP
Rather than ask you to install SQLite first, because SQLite is public
domain, DBD::SQLite includes the entire thing in the distribution. So
in order to get a fast transaction capable \s-1RDBMS\s0 working for your
perl project you simply have to install this module, and \fBnothing\fR
else.
.PP
SQLite supports the following features:
.IP "Implements a large subset of \s-1SQL92\s0" 4
.IX Item "Implements a large subset of SQL92"
See http://www.hwaci.com/sw/sqlite/lang.html for details.
.IP "A complete \s-1DB\s0 in a single disk file" 4
.IX Item "A complete DB in a single disk file"
Everything for your database is stored in a single disk file, making it
easier to move things around than with \s-1DBD::CSV.\s0
.IP "Atomic commit and rollback" 4
.IX Item "Atomic commit and rollback"
Yes, DBD::SQLite is small and light, but it supports full transactions!
.IP "Extensible" 4
.IX Item "Extensible"
User-defined aggregate or regular functions can be registered with the
\&\s-1SQL\s0 parser.
.PP
There's lots more to it, so please refer to the docs on the SQLite web
page, listed above, for \s-1SQL\s0 details. Also refer to \s-1DBI\s0 for details
on how to use \s-1DBI\s0 itself.
.SH "CONFORMANCE WITH DBI SPECIFICATION"
.IX Header "CONFORMANCE WITH DBI SPECIFICATION"
The \s-1API\s0 works like every \s-1DBI\s0 module does. Please see \s-1DBI\s0 for more
details about core features.
.PP
Currently many statement attributes are not implemented or are
limited by the typeless nature of the SQLite database.
.SH "DRIVER PRIVATE ATTRIBUTES"
.IX Header "DRIVER PRIVATE ATTRIBUTES"
.SS "Database Handle Attributes"
.IX Subsection "Database Handle Attributes"
.IP "sqlite_version" 4
.IX Item "sqlite_version"
Returns the version of the SQLite library which DBD::SQLite is using,
e.g., \*(L"2.8.0\*(R". Can only be read.
.IP "unicode" 4
.IX Item "unicode"
If set to a true value, DBD::SQLite will turn the \s-1UTF\-8\s0 flag on for all text
strings coming out of the database. For more details on the \s-1UTF\-8\s0 flag see
perlunicode. The default is for the \s-1UTF\-8\s0 flag to be turned off.
.Sp
Also note that due to some bizareness in SQLite's type system (see
http://www.sqlite.org/datatype3.html), if you want to retain
blob-style behavior for \fBsome\fR columns under \f(CW\*(C`$dbh\->{unicode} = 1\*(C'\fR (say, to store images in the database), you have to state so
explicitely using the 3\-argument form of \*(L"bind_param\*(R" in \s-1DBI\s0 when doing
updates:
.Sp
.Vb 6
\&    use DBI qw(:sql_types);
\&    $dbh\->{unicode} = 1;
\&    my $sth = $dbh\->prepare
\&         ("INSERT INTO mytable (blobcolumn) VALUES (?)");
\&    $sth\->bind_param(1, $binary_data, SQL_BLOB); # binary_data will
\&    # be stored as\-is.
.Ve
.Sp
Defining the column type as \s-1BLOB\s0 in the \s-1DDL\s0 is \fBnot\fR sufficient.
.SH "DRIVER PRIVATE METHODS"
.IX Header "DRIVER PRIVATE METHODS"
.ie n .SS "$dbh\->func('last_insert_rowid')"
.el .SS "\f(CW$dbh\fP\->func('last_insert_rowid')"
.IX Subsection "$dbh->func('last_insert_rowid')"
This method returns the last inserted rowid. If you specify an \s-1INTEGER PRIMARY
KEY\s0 as the first column in your table, that is the column that is returned.
Otherwise, it is the hidden \s-1ROWID\s0 column. See the sqlite docs for details.
.PP
Note: You can now use \f(CW$dbh\fR\->\fIlast_insert_id()\fR if you have a recent version of
\&\s-1DBI.\s0
.ie n .SS "$dbh\->func( 'busy_timeout' )"
.el .SS "\f(CW$dbh\fP\->func( 'busy_timeout' )"
.IX Subsection "$dbh->func( 'busy_timeout' )"
Retrieve the current busy timeout.
.ie n .SS "$dbh\->func( $ms, 'busy_timeout' )"
.el .SS "\f(CW$dbh\fP\->func( \f(CW$ms\fP, 'busy_timeout' )"
.IX Subsection "$dbh->func( $ms, 'busy_timeout' )"
Set the current busy timeout. The timeout is in milliseconds.
.ie n .SS "$dbh\->func( $name, $argc, $func_ref, ""create_function"" )"
.el .SS "\f(CW$dbh\fP\->func( \f(CW$name\fP, \f(CW$argc\fP, \f(CW$func_ref\fP, ``create_function'' )"
.IX Subsection "$dbh->func( $name, $argc, $func_ref, create_function )"
This method will register a new function which will be useable in \s-1SQL\s0
query. The method's parameters are:
.ie n .IP "$name" 4
.el .IP "\f(CW$name\fR" 4
.IX Item "$name"
The name of the function. This is the name of the function as it will
be used from \s-1SQL.\s0
.ie n .IP "$argc" 4
.el .IP "\f(CW$argc\fR" 4
.IX Item "$argc"
The number of arguments taken by the function. If this number is \-1,
the function can take any number of arguments.
.ie n .IP "$func_ref" 4
.el .IP "\f(CW$func_ref\fR" 4
.IX Item "$func_ref"
This should be a reference to the function's implementation.
.PP
For example, here is how to define a \fInow()\fR function which returns the
current number of seconds since the epoch:
.PP
.Vb 1
\&    $dbh\->func( \*(Aqnow\*(Aq, 0, sub { return time }, \*(Aqcreate_function\*(Aq );
.Ve
.PP
After this, it could be use from \s-1SQL\s0 as:
.PP
.Vb 1
\&    INSERT INTO mytable ( now() );
.Ve
.ie n .SS "$dbh\->func( $name, $argc, $pkg, 'create_aggregate' )"
.el .SS "\f(CW$dbh\fP\->func( \f(CW$name\fP, \f(CW$argc\fP, \f(CW$pkg\fP, 'create_aggregate' )"
.IX Subsection "$dbh->func( $name, $argc, $pkg, 'create_aggregate' )"
This method will register a new aggregate function which can then used
from \s-1SQL.\s0 The method's parameters are:
.ie n .IP "$name" 4
.el .IP "\f(CW$name\fR" 4
.IX Item "$name"
The name of the aggregate function, this is the name under which the
function will be available from \s-1SQL.\s0
.ie n .IP "$argc" 4
.el .IP "\f(CW$argc\fR" 4
.IX Item "$argc"
This is an integer which tells the \s-1SQL\s0 parser how many arguments the
function takes. If that number is \-1, the function can take any number
of arguments.
.ie n .IP "$pkg" 4
.el .IP "\f(CW$pkg\fR" 4
.IX Item "$pkg"
This is the package which implements the aggregator interface.
.PP
The aggregator interface consists of defining three methods:
.IP "\fInew()\fR" 4
.IX Item "new()"
This method will be called once to create an object which should
be used to aggregate the rows in a particular group. The \fIstep()\fR and
\&\fIfinalize()\fR methods will be called upon the reference return by
the method.
.IP "step(@_)" 4
.IX Item "step(@_)"
This method will be called once for each rows in the aggregate.
.IP "\fIfinalize()\fR" 4
.IX Item "finalize()"
This method will be called once all rows in the aggregate were
processed and it should return the aggregate function's result. When
there is no rows in the aggregate, \fIfinalize()\fR will be called right
after \fInew()\fR.
.PP
Here is a simple aggregate function which returns the variance
(example adapted from pysqlite):
.PP
.Vb 1
\&    package variance;
\&
\&    sub new { bless [], shift; }
\&
\&    sub step {
\&        my ( $self, $value ) = @_;
\&
\&        push @$self, $value;
\&    }
\&
\&    sub finalize {
\&        my $self = $_[0];
\&
\&        my $n = @$self;
\&
\&        # Variance is NULL unless there is more than one row
\&        return undef unless $n || $n == 1;
\&
\&        my $mu = 0;
\&        foreach my $v ( @$self ) {
\&            $mu += $v;
\&        }
\&        $mu /= $n;
\&
\&        my $sigma = 0;
\&        foreach my $v ( @$self ) {
\&            $sigma += ($x \- $mu)**2;
\&        }
\&        $sigma = $sigma / ($n \- 1);
\&
\&        return $sigma;
\&    }
\&
\&    $dbh\->func( "variance", 1, \*(Aqvariance\*(Aq, "create_aggregate" );
.Ve
.PP
The aggregate function can then be used as:
.PP
.Vb 2
\&    SELECT group_name, variance(score) FROM results
\&    GROUP BY group_name;
.Ve
.SH "BLOBS"
.IX Header "BLOBS"
As of version 1.11, blobs should \*(L"just work\*(R" in SQLite as text columns. However
this will cause the data to be treated as a string, so \s-1SQL\s0 statements such
as length(x) will return the length of the column as a \s-1NUL\s0 terminated string,
rather than the size of the blob in bytes. In order to store natively as a
\&\s-1BLOB\s0 use the following code:
.PP
.Vb 2
\&  use DBI qw(:sql_types);
\&  my $dbh = DBI\->connect("dbi:sqlite:/path/to/db");
\&  
\&  my $blob = \`cat foo.jpg\`;
\&  my $sth = $dbh\->prepare("INSERT INTO mytable VALUES (1, ?)");
\&  $sth\->bind_param(1, $blob, SQL_BLOB);
\&  $sth\->execute();
.Ve
.PP
And then retreival just works:
.PP
.Vb 4
\&  $sth = $dbh\->prepare("SELECT * FROM mytable WHERE id = 1");
\&  $sth\->execute();
\&  my $row = $sth\->fetch;
\&  my $blobo = $row\->[1];
\&  
\&  # now $blobo == $blob
.Ve
.SH "NOTES"
.IX Header "NOTES"
To access the database from the command line, try using dbish which comes with
the \s-1DBI\s0 module. Just type:
.PP
.Vb 1
\&  dbish dbi:SQLite:foo.db
.Ve
.PP
On the command line to access the file \fIfoo.db\fR.
.PP
Alternatively you can install SQLite from the link above without conflicting
with DBD::SQLite and use the supplied \f(CW\*(C`sqlite\*(C'\fR command line tool.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
SQLite is fast, very fast. I recently processed my 72MB log file with it,
inserting the data (400,000+ rows) by using transactions and only committing
every 1000 rows (otherwise the insertion is quite slow), and then performing
queries on the data.
.PP
Queries like count(*) and avg(bytes) took fractions of a second to return,
but what surprised me most of all was:
.PP
.Vb 4
\&  SELECT url, count(*) as count FROM access_log
\&    GROUP BY url
\&    ORDER BY count desc
\&    LIMIT 20
.Ve
.PP
To discover the top 20 hit URLs on the site (http://axkit.org), and it
returned within 2 seconds. I'm seriously considering switching my log
analysis code to use this little speed demon!
.PP
Oh yeah, and that was with no indexes on the table, on a 400MHz \s-1PIII.\s0
.PP
For best performance be sure to tune your hdparm settings if you are
using linux. Also you might want to set:
.PP
.Vb 1
\&  PRAGMA default_synchronous = OFF
.Ve
.PP
Which will prevent sqlite from doing fsync's when writing (which
slows down non-transactional writes significantly) at the expense of some
peace of mind. Also try playing with the cache_size pragma.
.SH "BUGS"
.IX Header "BUGS"
Likely to be many, please use http://rt.cpan.org/ for reporting bugs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt Sergeant, matt@sergeant.org
.PP
Perl extension functions contributed by Francis J. Lacoste
<flacoste@logreport.org> and Wolfgang Sourdeau
<wolfgang@logreport.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0.
