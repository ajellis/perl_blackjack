/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of SQLite.xs. Do not edit this file, edit SQLite.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "SQLite.xs"
/* $Id: SQLite.xs,v 1.8 2005/06/20 13:53:00 matt Exp $ */

#include "SQLiteXS.h"

DBISTATE_DECLARE;

#line 17 "SQLite.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 159 "SQLite.c"

XS_EUPXS(XS_DBD__SQLite__db_list_tables); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_list_tables)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
	AV *	RETVAL;
#line 18 "SQLite.xs"
    {
        RETVAL = newAV();
    }
#line 175 "SQLite.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_last_insert_rowid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_last_insert_rowid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 28 "SQLite.xs"
    {
        D_imp_dbh(dbh);
        RETVAL = sqlite3_last_insert_rowid(imp_dbh->db);
    }
#line 199 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_create_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_create_function)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, name, argc, func");
    {
	SV *	dbh = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	int	argc = (int)SvIV(ST(2))
;
	SV *	func = ST(3)
;
#line 42 "SQLite.xs"
    {
        sqlite3_db_create_function( dbh, name, argc, func );
    }
#line 225 "SQLite.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_DBD__SQLite__db_create_aggregate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_create_aggregate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, name, argc, aggr");
    {
	SV *	dbh = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	int	argc = (int)SvIV(ST(2))
;
	SV *	aggr = ST(3)
;
#line 53 "SQLite.xs"
    {
        sqlite3_db_create_aggregate( dbh, name, argc, aggr );
    }
#line 250 "SQLite.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_DBD__SQLite__db_busy_timeout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_busy_timeout)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, timeout=0");
    {
	SV *	dbh = ST(0)
;
	int	timeout;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    timeout = 0;
	else {
	    timeout = (int)SvIV(ST(1))
;
	}
#line 62 "SQLite.xs"
    RETVAL = dbd_set_sqlite3_busy_timeout( dbh, timeout );
#line 277 "SQLite.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE:  Including 'SQLite.xsi' from 'SQLite.xs' */

#include "Driver_xst.h"

XS_EUPXS(XS_DBD__SQLite__dr_dbixs_revision); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__dr_dbixs_revision)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 36 "./SQLite.xsi"
    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));
#line 298 "SQLite.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_discon_all
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_DBD__SQLite__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__dr_discon_all_)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "drh");
    {
	SV *	drh = ST(0)
;
#line 48 "./SQLite.xsi"
    D_imp_drh(drh);
    PERL_UNUSED_VAR(ix);
    ST(0) = dbd_discon_all(drh, imp_drh) ? &PL_sv_yes : &PL_sv_no;
#line 322 "SQLite.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_DBD__SQLite__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__dr_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "drh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 62 "./SQLite.xsi"
    {
        D_imp_drh(drh);
        AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 364 "SQLite.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__SQLite__db__login); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db__login)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dbh, dbname, username, password, attribs=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	dbname = ST(1)
;
	SV *	username = ST(2)
;
	SV *	password = ST(3)
;
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 92 "./SQLite.xsi"
    {
    D_imp_dbh(dbh);
#if !defined(dbd_db_login6_sv)
    STRLEN lna;
    char *u = (SvOK(username)) ? SvPV(username,lna) : "";
    char *p = (SvOK(password)) ? SvPV(password,lna) : "";
#endif
#ifdef dbd_db_login6_sv
    ST(0) = dbd_db_login6_sv(dbh, imp_dbh, dbname, username, password, attribs) ? &PL_sv_yes : &PL_sv_no;
#elif defined(dbd_db_login6)
    ST(0) = dbd_db_login6(dbh, imp_dbh, SvPV_nolen(dbname), u, p, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_db_login( dbh, imp_dbh, SvPV_nolen(dbname), u, p) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 411 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_selectall_arrayref)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 112 "./SQLite.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 429 "SQLite.c"
#line 118 "./SQLite.xsi"
    if (items > 2) {
        attr = ST(2);
        if (SvROK(attr) &&
                (DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
        ) {
            /* fallback to perl implementation */
            SV *tmp =dbixst_bounce_method("DBD::SQLite::db::SUPER::selectall_arrayref", items);
            SPAGAIN;
            ST(0) = tmp;
            XSRETURN(1);
        }
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth))
            XSRETURN_UNDEF;
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    ST(0) = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
#line 474 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_selectrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 168 "./SQLite.xsi"
    int is_selectrow_array = (ix == 1);
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 494 "SQLite.c"
#line 173 "./SQLite.xsi"
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        /* --- prepare --- */
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth)) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
        if (GIMME == G_SCALAR)
            PUSHs(&PL_sv_undef);
    }
    else if (is_selectrow_array) {
        int i;
        int num_fields = AvFILL(row_av)+1;
        if (GIMME == G_SCALAR)
            num_fields = 1; /* return just first field */
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(row_av)[i]);
        }
    }
    else {
        PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 550 "SQLite.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_db_do4 /* deebeedee-deebee-doo, deebee-doobee-dah? */
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_DBD__SQLite__db_do); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_do)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, statement, params = Nullsv");
    {
	SV *	dbh = ST(0)
;
	char *	statement = (char *)SvPV_nolen(ST(1))
;
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2)
;
	}
#line 237 "./SQLite.xsi"
    {
    D_imp_dbh(dbh);
    IV retval;
    retval = dbd_db_do4(dbh, imp_dbh, statement, params);
    /* remember that dbd_db_do4 must return <= -2 for error     */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
    }
#line 592 "SQLite.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_last_insert_id
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_DBD__SQLite__db_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_last_insert_id)
{
    dVAR; dXSARGS;
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "dbh, catalog, schema, table, field, attr=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	catalog = ST(1)
;
	SV *	schema = ST(2)
;
	SV *	table = ST(3)
;
	SV *	field = ST(4)
;
	SV *	attr;

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5)
;
	}
#line 264 "./SQLite.xsi"
    {
    D_imp_dbh(dbh);
    ST(0) = dbd_db_last_insert_id(dbh, imp_dbh, catalog, schema, table, field, attr);
    }
#line 632 "SQLite.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__SQLite__db_commit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_commit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 276 "./SQLite.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 653 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_rollback)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 286 "./SQLite.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 673 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_disconnect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 296 "./SQLite.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
        XSRETURN_YES;
    }
    /* Check for disconnect() being called whilst refs to cursors       */
    /* still exists. This possibly needs some more thought.             */
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !PL_dirty) {
        STRLEN lna;
        char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? "" : "s";
        warn("%s->disconnect invalidates %d active statement handle%s %s",
            SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
            "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
    DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
#line 704 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, keysv, valuesv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 319 "./SQLite.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 731 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_FETCH)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, keysv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
#line 333 "./SQLite.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;    /* dbd_db_FETCH_attrib did sv_2mortal   */
#line 754 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
#line 344 "./SQLite.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_dbh(dbh);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_dbh) && !PL_dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(dbh,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_dbh)) {            /* wants ineffective destroy */
            DBIc_ACTIVE_off(imp_dbh);
            if (DBIc_DBISTATE(imp_dbh)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_dbh), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(dbh));
        }
        if (DBIc_ACTIVE(imp_dbh)) {
            if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
                /* Application is using transactions and hasn't explicitly disconnected.
                    Some databases will automatically commit on graceful disconnect.
                    Since we're about to gracefully disconnect as part of the DESTROY
                    we want to be sure we're not about to implicitly commit changes
                    that are incomplete and should be rolled back. (The DESTROY may
                    be due to a RaiseError, for example.) So we rollback here.
                    This will be harmless if the application has issued a commit,
                    XXX Could add an attribute flag to indicate that the driver
                    doesn't have this problem. Patches welcome.
                */
                if (DBIc_WARN(imp_dbh) /* only warn if likely to be useful... */
                &&  DBIc_is(imp_dbh, DBIcf_Executed) /* has not just called commit/rollback */
            /*  && !DBIc_is(imp_dbh, DBIcf_ReadOnly) -- is not read only */
                && (!PL_dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3)
                ) {
                    warn("Issuing rollback() due to DESTROY without explicit disconnect() of %s handle %s",
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "ImplementorClass", 16, 1)),
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "Name", 4, 1))
                    );
                }
                dbd_db_rollback(dbh, imp_dbh);                  /* ROLLBACK! */
            }
            dbd_db_disconnect(dbh, imp_dbh);
            DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
        }
        dbd_db_destroy(dbh, imp_dbh);
    }
#line 817 "SQLite.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_DBD__SQLite__db_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_take_imp_data)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	SV *	h = ST(0)
;
#line 397 "./SQLite.xsi"
    D_imp_xxh(h);
    /* dbd_take_imp_data() returns &sv_no (or other defined but false value)
     * to indicate "preparations complete, now call SUPER::take_imp_data" for me.
     * Anything else is returned to the caller via sv_2mortal(sv), typically that
     * would be &sv_undef for error or an SV holding the imp_data.
     */
    SV *sv = dbd_take_imp_data(h, imp_xxh, NULL);
    if (SvOK(sv) && !SvTRUE(sv)) {
        SV *tmp = dbixst_bounce_method("DBD::SQLite::db::SUPER::take_imp_data", items);
        SPAGAIN;
        ST(0) = tmp;
    } else {
        ST(0) = sv_2mortal(sv);
    }
#line 851 "SQLite.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_data_sources
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_DBD__SQLite__db_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__db_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 421 "./SQLite.xsi"
    {
        D_imp_dbh(dbh);
        AV *av = dbd_db_data_sources(dbh, imp_dbh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 893 "SQLite.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__SQLite__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st__prepare)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, statement, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	statement = ST(1)
;
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2)
;
	}
#line 450 "./SQLite.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
#ifdef dbd_st_prepare_sv
    ST(0) = dbd_st_prepare_sv(sth, imp_sth, statement, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_prepare(sth, imp_sth, SvPV_nolen(statement), attribs) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 930 "SQLite.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_DBD__SQLite__st_rows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_rows)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 467 "./SQLite.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 951 "SQLite.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
#ifdef dbd_st_bind_col
#define XSubPPtmpAAAH 1


XS_EUPXS(XS_DBD__SQLite__st_bind_col); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_bind_col)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, col, ref, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	col = ST(1)
;
	SV *	ref = ST(2)
;
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 482 "./SQLite.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(ref))
        mg_get(ref);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_col", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    switch(dbd_st_bind_col(sth, imp_sth, col, ref, sql_type, attribs)) {
    case 2:     ST(0) = &PL_sv_yes;        /* job done completely */
                break;
    case 1:     /* fallback to DBI default */
                ST(0) = (DBIc_DBISTATE(imp_sth)->bind_col(sth, col, ref, attribs))
                    ? &PL_sv_yes : &PL_sv_no;
                break;
    default:    ST(0) = &PL_sv_no;         /* dbd_st_bind_col has called set_err */
                break;
    }
    }
#line 1011 "SQLite.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_bind_col */

XS_EUPXS(XS_DBD__SQLite__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_bind_param)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, param, value, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value = ST(2)
;
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 520 "./SQLite.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 1060 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_bind_param_inout)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "sth, param, value_ref, maxlen, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value_ref = ST(2)
;
	IV	maxlen = (IV)SvIV(ST(3))
;
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 550 "./SQLite.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
        croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
        croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 1115 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_execute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_execute)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "sth, ...");
    {
	SV *	sth = ST(0)
;
#line 581 "./SQLite.xsi"
    D_imp_sth(sth);
    int retval;
    if (items > 1) {    /* need to bind params */
        if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
            XSRETURN_UNDEF;
        }
    }
    /* XXX this code is duplicated in selectrow_arrayref above  */
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
        DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth);
    /* remember that dbd_st_execute must return <= -2 for error */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
#line 1149 "SQLite.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_execute_for_fetch
#define XSubPPtmpAAAI 1


XS_EUPXS(XS_DBD__SQLite__st_execute_for_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_execute_for_fetch)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, fetch_tuple_sub, tuple_status = Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	fetch_tuple_sub = ST(1)
;
	SV *	tuple_status;

	if (items < 3)
	    tuple_status = Nullsv;
	else {
	    tuple_status = ST(2)
;
	}
#line 609 "./SQLite.xsi"
    {
    D_imp_sth(sth);
    ST(0) = dbd_st_execute_for_fetch(sth, imp_sth, fetch_tuple_sub, tuple_status);
    }
#line 1182 "SQLite.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__SQLite__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_fetchrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 624 "./SQLite.xsi"
    D_imp_sth(sth);
    AV *av;
    PERL_UNUSED_VAR(ix);
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 1205 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_fetchrow_array)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 637 "./SQLite.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
        int i;
        int num_fields = AvFILL(av)+1;
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(av)[i]);
        }
        PERL_UNUSED_VAR(ix);
    }
#line 1236 "SQLite.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__SQLite__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_fetchall_arrayref)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef");
    {
	SV *	sth = ST(0)
;
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1)
;
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2)
;
	}
#line 657 "./SQLite.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        SV *tmp = dbixst_bounce_method("DBD::SQLite::st::SUPER::fetchall_arrayref", 3);
        SPAGAIN;
        ST(0) = tmp;
    }
    else {
        ST(0) = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
    }
#line 1277 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_finish); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_finish)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 671 "./SQLite.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
        /* No active statement to finish        */
        XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
        /* Either an explicit disconnect() or global destruction        */
        /* has disconnected us from the database. Finish is meaningless */
        DBIc_ACTIVE_off(imp_sth);
        XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &PL_sv_yes : &PL_sv_no;
#endif
#line 1310 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_blob_read)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "sth, field, offset, len, destrv=Nullsv, destoffset=0");
    {
	SV *	sth = ST(0)
;
	int	field = (int)SvIV(ST(1))
;
	long	offset = (long)SvIV(ST(2))
;
	long	len = (long)SvIV(ST(3))
;
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4)
;
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5))
;
	}
#line 699 "./SQLite.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 1356 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sth, keysv, valuesv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 715 "./SQLite.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 1383 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_FETCH_attrib)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "sth, keysv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
#line 732 "./SQLite.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    PERL_UNUSED_VAR(ix);
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;    /* dbd_st_FETCH_attrib did sv_2mortal   */
#line 1409 "SQLite.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__SQLite__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__SQLite__st_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 745 "./SQLite.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_sth(sth);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_sth) && !PL_dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_sth),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) {  /* wants ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
            if (DBIc_DBISTATE(imp_sth)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_sth), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(sth));
        }
        if (DBIc_ACTIVE(imp_sth)) {
            D_imp_dbh_from_sth;
            if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
                dbd_st_finish3(sth, imp_sth, 1);
#else
                dbd_st_finish(sth, imp_sth);
#endif
            }
            else {
                DBIc_ACTIVE_off(imp_sth);
            }
        }
        dbd_st_destroy(sth, imp_sth);
    }
#line 1458 "SQLite.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'SQLite.xs' from 'SQLite.xsi' */

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_DBD__SQLite); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_DBD__SQLite)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

    {
        CV * cv;

        newXS("DBD::SQLite::db::list_tables", XS_DBD__SQLite__db_list_tables, file);
        newXS("DBD::SQLite::db::last_insert_rowid", XS_DBD__SQLite__db_last_insert_rowid, file);
        newXS("DBD::SQLite::db::create_function", XS_DBD__SQLite__db_create_function, file);
        newXS("DBD::SQLite::db::create_aggregate", XS_DBD__SQLite__db_create_aggregate, file);
        newXS("DBD::SQLite::db::busy_timeout", XS_DBD__SQLite__db_busy_timeout, file);
        newXS("DBD::SQLite::dr::dbixs_revision", XS_DBD__SQLite__dr_dbixs_revision, file);
#if XSubPPtmpAAAA
        cv = newXS("DBD::SQLite::dr::discon_all_", XS_DBD__SQLite__dr_discon_all_, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::dr::disconnect_all", XS_DBD__SQLite__dr_discon_all_, file);
        XSANY.any_i32 = 1;
#endif
#if XSubPPtmpAAAB
        newXS("DBD::SQLite::dr::data_sources", XS_DBD__SQLite__dr_data_sources, file);
#endif
        newXS("DBD::SQLite::db::_login", XS_DBD__SQLite__db__login, file);
        newXS("DBD::SQLite::db::selectall_arrayref", XS_DBD__SQLite__db_selectall_arrayref, file);
        cv = newXS("DBD::SQLite::db::selectrow_array", XS_DBD__SQLite__db_selectrow_arrayref, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::db::selectrow_arrayref", XS_DBD__SQLite__db_selectrow_arrayref, file);
        XSANY.any_i32 = 0;
#if XSubPPtmpAAAC
        newXS("DBD::SQLite::db::do", XS_DBD__SQLite__db_do, file);
#endif
#if XSubPPtmpAAAD
        newXS("DBD::SQLite::db::last_insert_id", XS_DBD__SQLite__db_last_insert_id, file);
#endif
        newXS("DBD::SQLite::db::commit", XS_DBD__SQLite__db_commit, file);
        newXS("DBD::SQLite::db::rollback", XS_DBD__SQLite__db_rollback, file);
        newXS("DBD::SQLite::db::disconnect", XS_DBD__SQLite__db_disconnect, file);
        newXS("DBD::SQLite::db::STORE", XS_DBD__SQLite__db_STORE, file);
        newXS("DBD::SQLite::db::FETCH", XS_DBD__SQLite__db_FETCH, file);
        newXS("DBD::SQLite::db::DESTROY", XS_DBD__SQLite__db_DESTROY, file);
#if XSubPPtmpAAAE
        newXS("DBD::SQLite::db::take_imp_data", XS_DBD__SQLite__db_take_imp_data, file);
#endif
#if XSubPPtmpAAAF
        newXS("DBD::SQLite::db::data_sources", XS_DBD__SQLite__db_data_sources, file);
#endif
        newXS("DBD::SQLite::st::_prepare", XS_DBD__SQLite__st__prepare, file);
#if XSubPPtmpAAAG
        newXS("DBD::SQLite::st::rows", XS_DBD__SQLite__st_rows, file);
#endif
#if XSubPPtmpAAAH
        newXS("DBD::SQLite::st::bind_col", XS_DBD__SQLite__st_bind_col, file);
#endif
        newXS("DBD::SQLite::st::bind_param", XS_DBD__SQLite__st_bind_param, file);
        newXS("DBD::SQLite::st::bind_param_inout", XS_DBD__SQLite__st_bind_param_inout, file);
        newXS("DBD::SQLite::st::execute", XS_DBD__SQLite__st_execute, file);
#if XSubPPtmpAAAI
        newXS("DBD::SQLite::st::execute_for_fetch", XS_DBD__SQLite__st_execute_for_fetch, file);
#endif
        cv = newXS("DBD::SQLite::st::fetch", XS_DBD__SQLite__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::st::fetchrow_arrayref", XS_DBD__SQLite__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::st::fetchrow_array", XS_DBD__SQLite__st_fetchrow_array, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::SQLite::st::fetchrow", XS_DBD__SQLite__st_fetchrow_array, file);
        XSANY.any_i32 = 1;
        newXS("DBD::SQLite::st::fetchall_arrayref", XS_DBD__SQLite__st_fetchall_arrayref, file);
        newXS("DBD::SQLite::st::finish", XS_DBD__SQLite__st_finish, file);
        newXS("DBD::SQLite::st::blob_read", XS_DBD__SQLite__st_blob_read, file);
        newXS("DBD::SQLite::st::STORE", XS_DBD__SQLite__st_STORE, file);
        cv = newXS("DBD::SQLite::st::FETCH", XS_DBD__SQLite__st_FETCH_attrib, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::SQLite::st::FETCH_attrib", XS_DBD__SQLite__st_FETCH_attrib, file);
        XSANY.any_i32 = 0;
        newXS("DBD::SQLite::st::DESTROY", XS_DBD__SQLite__st_DESTROY, file);
    }

    /* Initialisation Section */

#line 12 "SQLite.xs"
    sv_setpv(get_sv("DBD::SQLite::sqlite_version", TRUE), SQLITE_VERSION);

#line 18 "./SQLite.xsi"
    PERL_UNUSED_VAR(items);
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::SQLite::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::SQLite::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::SQLite::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#line 1593 "SQLite.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

